#!/bin/sh

PATH=/bin:/usr/bin:/sbin:/usr/sbin

exec >/dev/null 2>&1

PATH=/bin:/usr/bin
CRASH_PATH="@CRASH_PATH@"
CRASH_TEMP="@CRASH_TEMP@"

DEBUG=1

# Expected invocation from kernel:
#
#   argv0 PID UID GID SIGNAL TIME CMD
pid="$1"
time="$5"
cmd="$6"

temp_dir="$(mktemp -d "${CRASH_TEMP}/crash.XXXXXX")"

name="${cmd}_${pid}_${time}"
result_path="${CRASH_PATH}/${name}.tar.gz"
pfx="${temp_dir}/${name}"
info_path="${pfx}/${name}.info"
core_path="${pfx}/${name}.coredump"
log_path="${pfx}/${name}.log"
tmp_callstack_path="${pfx}/${name}.callstack"
sysassert_cs_path="/tmp/crash_stack/${cmd}_${pid}.info"

mkdir -p "$CRASH_PATH" "$pfx"

if [ $DEBUG -eq 1 ]
then
  if [ "@SYS_ASSERT@" = "on" ]
  then
    mv "$sysassert_cs_path" "$pfx/"
  fi
#  @CRASH_STACK_PATH@ --pid "$pid" > "$tmp_callstack_path"
  @CRASH_PIPE_PATH@ --save-core "$core_path" --report "$@" > "$info_path"
#  cat "$tmp_callstack_path" >> "$info_path"
#  rm "$tmp_callstack_path"
else
  @CRASH_PIPE_PATH@ --report "$@" > "$info_path"
  @CRASH_STACK_PATH@ --pid "$pid" >> "$info_path"
fi

if [ "@CRASH_POPUP@" = "on" ]
then
#Find the full path of executable. The path is used to find appid in the crash-popup
	exepath=" "
	found=0
	while read line
	do
		if [ $found -eq 1 ]
		then
			exepath=$(echo $line | sed "s/0: //")
			break
		fi

		if [ "$line" = "Cmdline:" ]
		then
			found=1
		fi

	done < $info_path

#Call dbus method to launch the crash-popup
	/usr/bin/dbus-send --system --type=method_call --print-reply --reply-timeout=120000 --dest=org.tizen.system.popup /Org/Tizen/System/Popup/Crash org.tizen.system.popup.Crash.PopupLaunch dict:string:string:"_SYSPOPUP_CONTENT_","crash","_PROCESS_NAME_","${cmd}","_EXEPATH_","${exepath}"

fi

dump_systemstate -d -k -f "$log_path" || true

tar czf "${temp_dir}/report.tar.gz" -C "$temp_dir" "$name"
mv "${temp_dir}/report.tar.gz" "$result_path"

[ "$temp_dir" ] && rm -rf "$temp_dir"

